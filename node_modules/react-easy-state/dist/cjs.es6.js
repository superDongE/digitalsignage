'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var observerUtil = require('@nx-js/observer-util');
var reactPlatform_cjs = require('./react-platform.cjs');

// it is window in the DOM and global in NodeJS and React Native

const isDOM = typeof window !== 'undefined';
const isNative = typeof global !== 'undefined';
const globalObj = isDOM ? window : isNative ? global : undefined;
const hasHooks = typeof react.useState === 'function';

let isInsideFunctionComponent = false;
const COMPONENT = Symbol('owner component');
function view(Comp) {
  const isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);
  let ReactiveComp;

  if (isStatelessComp && hasHooks) {
    // use a hook based reactive wrapper when we can
    ReactiveComp = react.memo(props => {
      // use a dummy setState to update the component
      const [, setState] = react.useState(); // create a memoized reactive wrapper of the original component (render)
      // at the very first run of the component function

      const render = react.useMemo(() => observerUtil.observe(Comp, {
        scheduler: () => setState({}),
        lazy: true
      }), // Adding the original Comp here is necessary to make React Hot Reload work
      // it does not affect behavior otherwise
      [Comp]); // cleanup the reactive connections after the very last render of the component

      react.useEffect(() => {
        return () => observerUtil.unobserve(render);
      }, []); // the isInsideFunctionComponent flag is used to toggle `store` behavior
      // based on where it was called from

      isInsideFunctionComponent = true;

      try {
        // run the reactive render instead of the original one
        return render(props);
      } finally {
        isInsideFunctionComponent = false;
      }
    });
  } else {
    const BaseComp = isStatelessComp ? react.Component : Comp; // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount
    // it decides when to run the new reactive methods and when to proxy to the original methods

    class ReactiveClassComp extends BaseComp {
      constructor(props, context) {
        super(props, context);
        this.state = this.state || {};
        this.state[COMPONENT] = this; // create a reactive render for the component

        this.render = observerUtil.observe(this.render, {
          scheduler: () => this.setState({}),
          lazy: true
        });
      }

      render() {
        return isStatelessComp ? Comp(this.props, this.context) : super.render();
      } // react should trigger updates on prop changes, while easyState handles store changes


      shouldComponentUpdate(nextProps, nextState) {
        const {
          props,
          state
        } = this; // respect the case when the user defines a shouldComponentUpdate

        if (super.shouldComponentUpdate) {
          return super.shouldComponentUpdate(nextProps, nextState);
        } // return true if it is a reactive render or state changes


        if (state !== nextState) {
          return true;
        } // the component should update if any of its props shallowly changed value


        const keys = Object.keys(props);
        const nextKeys = Object.keys(nextProps);
        return nextKeys.length !== keys.length || nextKeys.some(key => props[key] !== nextProps[key]);
      } // add a custom deriveStoresFromProps lifecyle method


      static getDerivedStateFromProps(props, state) {
        if (super.deriveStoresFromProps) {
          // inject all local stores and let the user mutate them directly
          const stores = mapStateToStores(state);
          super.deriveStoresFromProps(props, ...stores);
        } // respect user defined getDerivedStateFromProps


        if (super.getDerivedStateFromProps) {
          return super.getDerivedStateFromProps(props, state);
        }

        return null;
      }

      componentWillUnmount() {
        // call user defined componentWillUnmount
        if (super.componentWillUnmount) {
          super.componentWillUnmount();
        } // clean up memory used by Easy State


        observerUtil.unobserve(this.render);
      }

    }

    ReactiveComp = ReactiveClassComp;
  }

  ReactiveComp.displayName = Comp.displayName || Comp.name; // static props are inherited by class components,
  // but have to be copied for function components

  if (isStatelessComp) {
    for (let key of Object.keys(Comp)) {
      ReactiveComp[key] = Comp[key];
    }
  }

  return ReactiveComp;
}

function mapStateToStores(state) {
  // find store properties and map them to their none observable raw value
  // to do not trigger none static this.setState calls
  // from the static getDerivedStateFromProps lifecycle method
  const component = state[COMPONENT];
  return Object.keys(component).map(key => component[key]).filter(observerUtil.isObservable).map(observerUtil.raw);
}

function store(obj) {
  // do not create new versions of the store on every render
  // if it is a local store in a function component
  // create a memoized store at the first call instead
  if (hasHooks && isInsideFunctionComponent) {
    return react.useMemo(() => observerUtil.observable(obj), []);
  }

  return observerUtil.observable(obj);
}

/* eslint camelcase: 0 */
// until the function is finished running

function batch(fn, ctx, args) {
  let result;
  reactPlatform_cjs.unstable_batchedUpdates(() => result = fn.apply(ctx, args));
  return result;
} // this creates and returns a batched version of the passed function
// the cache is necessary to always map the same thing to the same function
// which makes sure that addEventListener/removeEventListener pairs don't break

const cache = new WeakMap();

function batchFn(fn) {
  if (typeof fn !== 'function') {
    return fn;
  }

  let batched = cache.get(fn);

  if (!batched) {
    batched = function (...args) {
      return batch(fn, this, args);
    };

    cache.set(fn, batched);
  }

  return batched;
} // batched obj.addEventListener(cb) like callbacks


function batchMethodsCallbacks(obj, methods) {
  methods.forEach(method => batchMethodCallbacks(obj, method));
}

function batchMethodCallbacks(obj, method) {
  const descriptor = Object.getOwnPropertyDescriptor(obj, method);

  if (descriptor && descriptor.writable && typeof descriptor.value === 'function') {
    obj[method] = new Proxy(descriptor.value, {
      apply(target, ctx, args) {
        return Reflect.apply(target, ctx, args.map(batchFn));
      }

    });
  }
} // batches obj.onevent = fn like calls


function batchMethods(obj, methods) {
  methods.forEach(method => batchMethod(obj, method));
}

function batchMethod(obj, method) {
  const descriptor = Object.getOwnPropertyDescriptor(obj, method);

  if (descriptor && descriptor.configurable) {
    const newDescriptor = Object.assign({}, descriptor, {
      set(value) {
        return descriptor.set.call(this, batchFn(value));
      }

    });
    Object.defineProperty(obj, method, newDescriptor);
  }
} // do a sync batching for the most common task sources
// this should be removed when React's own batching is improved in the future
// batch timer functions


batchMethodsCallbacks(globalObj, ['setTimeout', 'setInterval', 'requestAnimationFrame', 'requestIdleCallback']);

if (globalObj.Promise) {
  batchMethodsCallbacks(Promise.prototype, ['then', 'catch']);
} // batch addEventListener calls


if (globalObj.EventTarget) {
  batchMethodsCallbacks(EventTarget.prototype, ['addEventListener', 'removeEventListener']);
} // this batches websocket event handlers


if (globalObj.WebSocket) {
  batchMethods(WebSocket.prototype, ['onopen', 'onmessage', 'onerror', 'onclose']);
} // HTTP event handlers are usually wrapped by Promises, which is covered above

exports.batch = batch;
exports.store = store;
exports.view = view;
//# sourceMappingURL=cjs.es6.js.map
